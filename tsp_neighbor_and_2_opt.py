import math
import copy


def tsp(data_temp):
    size = len(data_temp)
    add_index(data_temp, size)
    length = [0]*size
    all_paths = [0]*size
    new_data = [0]*size

    for k in range(size):
        data = copy.deepcopy(data_temp)
        city = data.pop(k)
        start = city
        path = [city[2]]
        new_data[k] = [city]

        for i in range(size - 1):
            min_path = []
            for j in range(size - 1 - i):
                min_path.append(distance(city, data[j]))
            m = min(min_path, key=lambda x: x[0])
            new_index = min_path.index(m)
            length[k] += m[0]
            path.append(m[1])
            new_data[k].append(data_temp[m[1]])
            city = data.pop(new_index)

        path.append(path[0])
        length[k] += distance(city, start)[0]
        all_paths[k] = path

    n = min(length)
    path_index = length.index(n)
    new_data = new_data[path_index]
    length, path = two_opt_main(new_data)

    return length, path


def distance(city_a, city_b):
    return math.sqrt((city_b[0] - city_a[0]) ** 2 + (city_b[1] - city_a[1]) ** 2), city_b[2]


def distance_opt(city_a, city_b):
    return math.sqrt((city_b[0] - city_a[0]) ** 2 + (city_b[1] - city_a[1]) ** 2)


def add_index(data, size):
    for index in range(size):
        data[index].append(index)


def two_opt_main(route):

    path = [i[2] for i in route]
    best_distance = route_distance(route)
    temp = 1000000

    while best_distance < temp:
        temp = best_distance
        for i in range(len(route)-1):
            for j in range(len(route)):
                new_route = two_opt_swap(route, i, j)
                distance = route_distance(new_route)
                if distance < best_distance:
                    best_distance = distance
                    route = new_route
                    path = two_opt_swap(path, i , j)
    path.append(path[0])

    return best_distance, path


def two_opt_swap(route, i, j):
    new_a = route[:i]
    new_b = list(reversed(route[i:j]))
    new_c = route[j:]
    return new_a + new_b + new_c


def route_distance(route):
    d = 0
    for i in range(len(route)-1):
        d += distance_opt(route[i], route[i+1])
    d += distance_opt(route[len(route)-1], route[0])
    return d


def description():
    return "Реалізовано метод \"найближчого сусіда\" для початкового вибору маршруту. " \
           "Далі для покращення результату використовується 2-opt алгоритм до того " \
           "моменту, поки результат більше не можна покращити.\n" \
           "\n" \
           "Метод \"найближчого сусіда\": для пошуку шляху обраховується відстань від початкової точки " \
           "до кожної іншої. Ми переходимо до точки, відстань до якої найменша і " \
           "приймаємо цю точку за початкову. Так проходиться весь шлях. В кінці ми повертаємось " \
           "до першої точки.\n" \
           "Для покращення результату алгоритму за початкову точку беремо всі міста з масиву по черзі " \
           "і знаходимо найкоротший шлях.\n" \
           "2-opt алгоритм: якщо подивитись на візуалізацію роботи цього алгоритму на графі, то побачимо, " \
           "що беруться два ребра за раз (ті, які перетинаються) і міняються місцями. Якщо зміна " \
           "покращила шлях, то беруться інша ребра, а якщо ні - то вертаються назад.\n" \
           "Для покращення результату алгоритму 2-opt використовуємо цикл while поки " \
           "результат не перестане покращуватись.\n" \
           "Хоча використання усіх наведених алгоритмів покращує отриманий результат, " \
           "в певних ситуаціях доцільно використовувати лише метод \"найближчого сусіда\", " \
           "адже він дає \"good enough\" результат за набагато менший час."

data = [[1380, 939], [2848, 96], [3510, 1671], [457, 334], [3888, 666], [984, 965], [2721, 1482], [1286, 525], [2716, 1432], [738, 1325], [1251, 1832], [2728, 1698], [3815, 169], [3683, 1533], [1247, 1945], [123, 862], [1234, 1946], [252, 1240], [611, 673], [2576, 1676], [928, 1700], [53, 857], [1807, 1711], [274, 1420], [2574, 946], [178, 24], [2678, 1825], [1795, 962], [3384, 1498], [3520, 1079], [1256, 61], [1424, 1728], [3913, 192], [3085, 1528], [2573, 1969], [463, 1670], [3875, 598], [298, 1513], [3479, 821], [2542, 236], [3955, 1743], [1323, 280], [3447, 1830], [2936, 337], [1621, 1830], [3373, 1646], [1393, 1368], [3874, 1318], [938, 955], [3022, 474], [2482, 1183], [3854, 923], [376, 825], [2519, 135], [2945, 1622], [953, 268], [2628, 1479], [2097, 981], [890, 1846], [2139, 1806], [2421, 1007], [2290, 1810], [1115, 1052], [2588, 302], [327, 265], [241, 341], [1917, 687], [2991, 792], [2573, 599], [19, 674], [3911, 1673], [872, 1559], [2863, 558], [929, 1766], [839, 620], [3893, 102], [2178, 1619], [3822, 899], [378, 1048], [1178, 100], [2599, 901], [3416, 143], [2961, 1605], [611, 1384], [3113, 885], [2597, 1830], [2586, 1286], [161, 906], [1429, 134], [742, 1025], [1625, 1651], [1187, 706], [1787, 1009], [22, 987], [3640, 43], [3756, 882], [776, 392], [1724, 1642], [198, 1810], [3950, 1558], [3477, 949], [91, 1732], [3972, 329], [198, 1632], [1806, 733], [538, 1023], [3430, 1088], [2186, 766], [1513, 1646], [2143, 1611], [53, 1657], [3404, 1307], [1034, 1344], [2823, 376], [3104, 1931], [3232, 324], [2790, 1457], [374, 9], [741, 146], [3083, 1938], [3502, 1067], [1280, 237], [3326, 1846], [217, 38], [2503, 1172], [3527, 41], [739, 1850], [3548, 1999], [48, 154], [1419, 872], [1689, 1223], [3468, 1404], [1628, 253], [382, 872], [3029, 1242], [3646, 1758], [285, 1029], [1782, 93], [1067, 371], [2849, 1214], [920, 1835], [1741, 712], [876, 220], [2753, 283], [2609, 1286], [3941, 258], [3613, 523], [1754, 559], [2916, 1724], [2445, 1820]]
print(tsp(data))
